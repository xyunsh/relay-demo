# Refetch容器
Refetch容器和常规得[Fragment容器](fragment-container.md)一样,也是一个[高阶容器](https://reactjs.org/docs/higher-order-components.html),但是它提供了使用不同变量获取一个新的GraphQL查询,并根据结果重绘组件得附加功能.

内容列表
- [createRefetchContainer](#user-content-createRefetchContainer)
- [refetch](#user-content-refetch)
- [示例](#user-content-示例)

## createRefetchContainer
createRefetchContainer具有如下签名:
```js
createRefetchContainer(
    component: ReactComponentClass,
    fragmentSpec: GraphQLTaggedNode | {[string]:GraphQLTaggedNode},
    refetchQuery: GraphQLTaggedNode
): ReactComponentClass
```

### 参数
- component: 需要fragment数据的组件对应的React组件类.
- fragmentSpec: 通过GraphQL fragment为组件指定数据需求. 需要的数据以属性props提供给组件,并和fragment中的形式一致.fragmentSpec可以是下面两者之一:
    - 一个graphql标签化的fragment.如果fragment约定命名为&lt;FileName&gt;&lt;...&gt;_&lt;propName&gt;,fragment的数据将以属性&lt;propName&gt;传递给组件.如果fragment的名称未指定一个属性名,data将作为属性传递.
    - 由属性名和grapql标签fragment分别为键值的对象. 对象的每个key将作为属性传递给组件.
    - **注意**:启用[兼容模式](relay-compat.md),relay-compiler将强制fragment命名为&lt;FileName&gt;_&lt;propName&gt;.
- refetchQuery: graphql标签查询, 当调用props.relay.refetch时执行查询. 和任何查询一样,当获取该查询时,其结果将被标准化到存储中, 并将触发与更改记录相关的订阅, 并且将重绘订阅组件. 

### 可访问属性
由createRefetchContainer生成的组件会接收如下属性:
```js
type Props = {
    relay: {
        environment: Environment,
        refetch(), // 查看#refetch
    },

    // 其他有fragmentSpec指定的属性
    ...
}
```
- relay: 
    - environment: 当前[Relay环境](relay-environment.md)
    - refetch: 查看refetch[文档](refetch-container.md#refetch)

## refetch
refetch是一个relay属性上的函数,可用于执行refetchQuery并可用新获取的数据重绘组件. 具体来说, 在获取refetchQuery是, 其结果将被标准化到存储中, 并且将触发与变更数据相关的任何订阅, 从而导致相关组件重新渲染.

**注意**:refetch被用于修改组件的fragment内部的变量.具体说,为了组件重绘,它必须订阅该查询影响的记录的修改.如果该组件的fragment未使用变量, 该组件不会订阅该查询获取的新记录.常见的使用refetch的例子是获取一个新节点,并且用该节点的数据重绘组件;在这里fragment需要吧节点的id作为变量,否则组件不会响应新节点的变更.

refetch 具有如下签名:
```js
type RefetchOptions = {
    force?: boolean
}

type Disposable = {
    dispose(): void
}

refetch(
    refetchVariables: Object | (fragmentVariables:Object) => Object,
    renderVariables: ?Object,
    callback: ?(error:?Error) => void,
    options?: RefetchOptions,
) : Disposable
```
### 参数

### 返回值
返回一个Disposable, 你可以调用dispose()取消查询.

## 示例
### 重新获取最新数据
在这个简单的示例中,我们假设需要从服务器获取最新的TodoItem数据.
```js
// TodoItem.js
import { createRefetchContainer, graphql } from 'react-relay';

class TodoItem extends React.Component {
    render(){
        const item = this.props.item;
        return (
            <View>
                <Checkbox checked={item.isComplete}/>
                <Text>{item.text}</Text>
                <button onPress={this._refetch} title="Refetch"/>
            </View>
        );
    }

    _refetch = () => {
        this.props.relay.refetch(
            {itemID: this.props.item.id },
            null,
            () => { console.log("Refetch Done"); },
            { force:true }
        )
    }
}

export default createRefetchContainer(
    TodoItem,
    graphql`
        fragment TodoItem_item on Todo {
            text
            isComplete
        }
    `,
    graphql`
        query TodoItemRefetchQuery($itemID:ID!){
            item: node(id:$itemID){
                ...TodoItem_item
            }
        }
    `
);
```

### 加载更多数据
在这个示例中,我们使用一个Refetch容器在一个story feed组件中获取更多的stories.
```js
import { createRefetchContainer, grapqhl } from 'react-relay';

class FeedStories extends React.Component {
    render(){
        return (
            <div>
                {this.props.feed.stories.edges.map(edge=><Story story={edge.node} key={edge.node.id}/>)}
                <button onPress={this._loadMore} title="Load More"/>
            </div>
        );
    }

    _loadMore = () => {
        const refetchVariables = fragmentVariables => ({
            count: fragmentVariables.count + 10,
        });

        this.props.relay.refetch(refetchVariables);
    }
}

export default createRefetchContainer(
    FeedStories,
    {
        feed: graphql`
            fragment FeedStories_feed on Feed {
                @argumentDefinition(
                    count: { type: "Int", defaultValue: 10 }
                ) {
                    stories(first:$count){
                        edges {
                            node {
                                id,
                                ...Story_story
                            }
                        }
                    }
                }
            }
        `
    },
    graphql`
        query FeedStoriesReftchQuery($count: Int){
            feed {
                ...FeedStories_feed @argument(count:$count)
            }
        }
    `
);  
```