# 快速入门
我们将通过一个todo list程序作为例子, 简要介绍Relay是如何工作的和使用的. 更多信息请参照指南和API部分.

内容列表
- [设置](#user-content-设置)
- [Relay环境](#user-content-Relay环境)
- [绘制GraphQL查询](#user-content-绘制GraphQL查询)
- [使用查询参数](#user-content-使用查询参数)
- [使用Fragments](#user-content-使用Fragments)
- [组合Fragments](#user-content-组合Fragments)
- [绘制Fragments](#user-content-绘制Fragments)
- [数据变更](#user-content-数据变更)
- [下一步](#user-content-下一步)

## 设置
您已经熟悉了[前置条件](prerequisites.md)和[安装和设置](installation-and-setup.md), 作为先决条件,假定您已经设置了GraphQL服务器和Schema.

幸运的是, 我们作为[例子的todo list](https://github.com/relayjs/relay-examples/tree/master/todo), 已经内置了[服务器](https://github.com/relayjs/relay-examples/blob/master/todo/server.js)和[schema](https://github.com/relayjs/relay-examples/blob/master/todo/data/schema.graphql)供我们使用.

```graphql
# From schema.graphql
# https://github.com/relayjs/relay-examples/blob/master/todo/data/schema.graphql

type Query {
    viewer: User

    # Fetches an object given its ID
    node(
        # The ID of an object
        id: ID!
    ): Node
}
```
另外,我们在代码内部使用[Flow](https://flow.org/).Flow是一个可选项,但是我们在示例中完全使用Flow.

## Relay环境
在我们使用Relay渲染程序之前,我们需要配置Relay环境:包括配置,缓存,网络处理.

作为例子,我们简单的配置环境和已存在的Graphql服务进行通讯.
```js
import {
    Environment,
    Network,
    RecordStore,
    Store
} from 'relay-runtime';

function fetchQuery(
    operation,
    variables,
) {
    return fetch('/graphql',{
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            query: operation.text,
            variables,
        }),
    }).then( response => response.json() );
}

const environment = new Enviroment({
    network: Network.create(fetchQuery),
    store: new Store( new RecordSource() ),
});

export default enviroment;
```
Relay运行环境至少需要[存储(Store)](relay-store.md)和[网络层(Network layer)](network-layer.md).上面的代码使用了Store的缺省实现,并且创建了一个[网络层(Network layer)](network-layer.md)用于fetchQuery函数获取来自服务端的GraphQL.

通常在我们的应用程序中,需要一个简单的环境配置,所以你可以把这个配置作为单例导出,这样可以让整个程序访问.

## 绘制GraphQL查询
现在我们已经配置了Relay环境,我们可以开始获取查询数据并绘制在屏幕上.react-relay提供的[QueryRenderer](query-renderer.md)组件可以作为绘制GraphQL查询的进入点.

作为开始,我们假定需要在屏幕上绘制用户id.从我们的Schema可以得知可以通过viewer获取当前用户,因此我们可以书写一个简单的查询来获取当前用户id:
```graphql
query UserQuery {
    viewer {
        id
    }
}
```
现在,我们看看如何创建一个组件用户绘制上面的查询:
```javascript
// App.js
import React from 'react';
import {graphql, QueryRender} from 'react-relay';

const environment = /* defined or import above... */;

export default class App extends React.Component {
    render() {
        return (
            <QueryRender
                environment={environment}
                query={graphql`
                    query UserQuery {
                        viewer {
                            id
                        }
                    }
                `}
                variables={{}}
                render={({error, props})=>{
                    if(error){
                        return <div>Error!</div>;
                    }

                    if(!props){
                        return <div>Loading...</div>;
                    }

                    return <div>User ID: {props.viewer.id}</div>;
                }}
            />
        );
    }
}
```
上面的代码绘制了一个 QueryRenderer, 像其他的React组件一样, 我们看看在属性(props)传入了什么:
- 前面定义的 environment
- 使用graphl函数定义GraphQL查询. graphql不会在运行时执行,而是通过[Relay编译器](graphql-in-relay.md#relay-compiler)生成Relay需要的运行时工件. 这部分我们先不关心,更多的细节请参考[GraphQL in Relay](graphql-in-relay.md)文档.
- 空对象 variables. 下一节我们再讨论如何使用variables.
- render函数,从代码中我们可以看到,Relay会给出一些错误信息,以及是否还在执行query.如果调用成功,数据将在props中可用,名称和查询中一致.

我们需要先使用Relay Compiler编译查询才能运行程序. 如果在[安装和设置](3.installatin-and-setup.md)设置好了,我可以直接运行 yarn relay.

关于 QueryRenderer 更多的细节,我们可以查看[文档](query-renderer.md).

## 使用查询参数
假设我们的程序需要展示不同的用户信息,因此我们需要通过id查询用户.从[schema](https://github.com/relayjs/relay-examples/blob/master/todo/data/schema.graphql#L69)中我们可以了解可以通过id查询信息. 因此我们可以书写如下的参数化查询:
```graphql
query UserQuery($userID: ID!) {
    node(id: $userID){
        id
    }
}
```
下面我们看看如何使用上面的查询:
```javascript
// UserTodoList.js
// @flow
import React from 'react';
import PropTypes from 'prop-types';
import {graphql, QueryRenderer} from 'react-relay';

const environment = /* defined or imported above... */;

type Props = {
    userID: string,
}

export default class UserTodoList extends React.COmponent<Props> {
    render() {
        const { userID } = this.props;

        return (
            <QueryRenderer
                environment={environment}
                query={
                    graphql`
                        query UserQuery($userID: ID!){
                            node(id: $userID) {
                                id
                            }
                        }
                    `
                }
                variables={{userID}}
                render={({error,props})=>{
                    if(error){
                        return <div>Error!</div>;
                    }

                    if(!props){
                        return <div>Loading...</div>;
                    }

                    return <div>User ID:{props.node.id}</div>;
                }}
            />
        );
    }
}
```
上面的代码和[之前例子](quick-start-guide.md#rendering-graphql-queries)非常相似. 不管怎样,我们通过variables属性传入$userID变量给GraphQL查询.这里有些需要注意的地方:
- userID 作为组件的属性,可能从父组件传入新的userID。这时候新的variables将传入QueryRenderer,这将自动导致根据新的userID重新从服务端获取数据.
- $userID变量可以在查询内部任何地方都可以访问,当组件作为fragments使用的时候,这一点非常重要.

现在我们需要更新查询, 不要忘记运行yarn relay.

## 使用Fragments
现在我们开始学习如何定义和使用查询,我们开始真正创建todo list.

我们从下面的代码开始,假设我们仅仅需要一个显示todo item的文本和完成状态的组件:
```javascript
// Todo.js
import React from 'react';

type Props = {
    todo: {
        complete:boolean,
        text:string
    },
};

export default class Todo extends React.Component<Props>{
    render(){
        const { complete, text } = this.props.todo;

        return (
            <li>
                <div>
                    <input checked={complete} type="checkbox"/>
                    <label>{text}</label>
                </div>
            </li>
        );
    }
}

```

从schema中,我们可以知道可以通过Todo类型来查询这些数据. 然而,我们并不想对每一个todo item发送一个查询请求;这会破坏在传统Rest API上使用GraphQL的目的.我们可以在QueryRenderer上直接手动处理这些字段，但是这样又会破坏重用性:我们如何通过一个查询的一部分来查询这些字段？我们并不知道哪些组件需要我们查询的这些数据,这将是Relay需要直面解决的问题.

相反,我们可以定义一个可复用的Fragment,允许我们在一个类型上定义一个字段的集合，并可以在我们的任何需要的地方重用它们:
```graphql
fragment TodoItemFragment on Todo {
    complete,
    text
}
```
我们的组件可以使用fragment去申明它在Todo GraphQL类型上的数据依赖.
```javascript
// Todo.js

// OPTIONAL: Flow type generated after running `yarn relay`, defining an Object type with shape of fragment
import type { Todo_todo } from './__generated__/Todo_todo.graphql';

import React from 'react';
import { graphql, createFragmentContainer } from 'react-relay';

type Props = {
    todo: Todo_todo
};

class Todo extends React.Component<Props>{
    render(){
        const { complete, text } = this.props.todo;

        return (
            <li>
                <div>
                    <input checked={ complete } type="checkbox"/>
                    <label>{text}</label>
                </div>
            </li>
        );
    }
}

export default createFragmentContainer(
    Todo,
    graphql`
        fragment Todo_todo on Todo {
            complete,
            text
        }
    `
)
```
上面的代码着重介绍了Relay最终的原则之一,即共置组件和其数据依赖关系。这有利于以下几点原因:
- 使得组件需要的数据一目了然，而不需要在应用中查找是哪个查询获取的数据.
- 作为必然的结果,组件从呈现它的查询中解偶，我们可以更改组件的数据依赖性,而无需更新呈现他们的查询或者担心破坏其他组件.

可以查看[Thinking in Relay]()获取更多的细节.

运行之前,不要忘了运行yarn relay来调用Relay编译器.

## 组合Fragments
[Fragment Container](fragment-container.md)仅仅是一个React组件,因此我们可以组合它们.甚至可以在其他的fragment容器中重用fragment容器.作为例子, 我们看看如何绘制一组todo item, 以及每个item的状态和文字.

```javascript
// TodoList.js
// OPTIONAL: Flow type generated after running `yarn relay`, defining an Object type with shape of the fragment:
import type {TodoList_userTodoData} from './__generated__/TodoList_userTodoData.graphql';

import React from 'react';
import { graphql, createFragmentContainer } from 'react-relay';

type Props = {
    userTodoData: TodoList_userTodoData
}

class TodoList extends React.Component{
    render(){
        const { userTodoData : { totalCount, completedCount, todos }} = this.props;

        return (
            <secton>
                <input checked={totaoCount==completedCount} type="checkbox"/>
                <ul>
                    {todos.edges.map((edge)=><Todo key={edge.node.id} todo={edge.node}/>)}
                </ul>
            </secton>
        );
    }
}

export default createFragmentContainer(
    TodoList,
    graphql`
        # 作为约定,fragment命名为 '组件文件名_属性名'
        fragment TodoList_userTodoData on User {
            todos (
                first: 2147483647  # max GraphQLInt, to fetch all todos
            ){
                edges {
                    node {
                        id
                        # We use the fragment defined by the child Todo component here
                        ...Todo_todo
                    },
                },
            },
            id,
            totalCount,
            completedCount
        }
    `
);
```
和我们定义的第一个fragment容器一样,TodoList通过fragment声明了它的数据依赖.这个组件复用了之前定义的Todo组件, 并通过属性传入了适当的数据.

值得注意的是,使用组合fragment的时候,父组件不能访问子组件定义的数据.Relay允许且仅允许组件访问GraphQL fragment定义的数据. 这种特性被称作[数据屏蔽(Data Masking)](thinking-in-relay.md#data-masking),它旨在防止组件依赖于未声明的数据依赖.

## 绘制Fragments
现在我们定义了一些组件,并声明了它的数据依赖,我们需要挂在QueryRenderer上,以便数据能被正确的呈现.记住,fragment容器并不直接获取数据.相反,容器声明绘制需要的数据规范,Relay保证在绘制之前数据可用.

QueryRenderer绘制fragment容器如下:
```javascript
// ViewerTodoList.js
import React from 'react';
import PropTypes from 'prop-types';
import { graphql, QueryRenderer } from 'react-relay';
import TodoList from './TodoList';

const environment = /* defined or imported above... */

export default class ViewerTodoList extends React.Component {
    render(){
        return (
            <QueryRenderer
                environment={environment}
                query={`graphql
                    query ViewerQuery {
                        viewer {
                            id
                            # 复用fragment
                            ...TodoList_userTodoData
                        }
                    }    
                `}
                variables={{}}
                render={({error, props})=>{
                    if(error){
                        return <div>Error!</div>;
                    }
                    if(!props){
                        return <div>Loading...</div>;
                    }

                    return (
                        <div>
                            <div> Todo list for User {props.viewer.id}:</div>
                            <TodoList userTodoData={props.viewer}/>
                        </div>
                    );
                }}
            />;
        );
    }
}
```
查看[Fragment容器](fragment-container.md)文档获取更多的细节,指南中关于[刷新(Refresh)](refetch-container.md)和[分页(Pagination)](pagination-container.md)部分有关于容器的更高级的用法.

## 数据变更
我们已经知道了如何查询并绘制数据,现在我们来尝试修改数据.我们知道修改服务器上的数据,我们需要使用GraphQL [变更(Mutations)](http://graphql.org/learn/queries/#mutations).

从[schema](https://github.com/relayjs/relay-examples/blob/master/todo/data/schema.graphql#L35)中,我们知道哪些变更是被允许的.我们开始编写一个变更来修改todo item的完成状态.

```graphql
mutation ChangeTodoStatusMutation($input: ChangeTodoStatusInput!){
    changeTodoStatus(input: $input){
        todo {
            id
            complete
        }
    }
}
```
这个变更运行我们将[变更的结果](https://github.com/relayjs/relay-examples/blob/master/todo/data/schema.graphql#L18)作为查询返回一些数据,因此我们可以查询todo item的complete变更后的状态.

为了在Relay中执行这次变更,我们需要用Relay的 commitMutation api来书写一个新的变更:
```javascript
// ChangeTodoStatusMutation.js

import { graphql, commitMutation } from 'react-relay';

// 通过 `graphql`定义变更
const mutation = graphql`
        mutation ChangeTodoStatusMutation($input:ChangeTodoStatusInput!) {
            changeTodoStatus(input:$input){
                todo {
                    id
                    complete
                }
            }
        }
    `;

function commit(
    environment,
    complete,
    tood,
) {
    return commitMutation(
        environment,
        {
            mutation,
            variables: {
                input: { complete, id: todo.id }
            }
        }
    );
}

export default { commit };
```
每当我们调用ChangeTodoStatusMutation.commit(...), Relay将变更提交到服务端,在我们的例子中,通过接受应答数据,Relay会用从服务端返回的数据更新本地存储.这也意味着,通过响应接收的应答,Relay可以确保依赖更新数据的任何组件(例如容器)重绘.

为了在组件中使用变更,我们通过下面的方法更新Todo组件:
```javascript
// Todo.js
// ...

class Todo extends React.Component<Props>{
    // Add a new event handler that fires off the mutation
    _handleOnCheckboxChange = (e) => {
        const complete = e.target.checked;

        ChangeTodoStatusMutation.commit(
            this.props.relay.environment,
            complete,
            this.props.todo
        );
    };

    render() {
        //...
    }
}

//...
```

### 乐观更新(Optimistic Updates)
在我们上面的示例中,complete状态直到服务器返回结果之后才会更新重绘,这样并不能带给用户最佳的体验.

为了更好的体验,我们可以配置变更实现乐观更新.乐观更新意味着立即采用服务端期望d的数据更新本地数据.如果请求不成功,则回滚我们的更新.

在Relay中,我们可以传入一些选项到commitMutation中实现乐观更新.我们看看在ChangeTodoStatusMutation中如何实现乐观更新:
```javascript
//ChangeTotoStatusMutation.js

//...
function getOptimisticResponse(complete, todo){
    return ({
        changeTodoStatus: {
            todo: {
                complete: complete,
                id: todo.id
            }
        }
    });
}

function commit(
    environment,
    complete,
    todo
){
    return commitMutation(
        environment,
        variables: {
            input: { complete, id: todo.id },
        },
        optimisticResponse: getOptimisticResponse(complete, todo),
    )
}

export default { commit };
```
在上面最简单的情况下,我们只需要传入一个optimisticResponse选项,该选项应该引用一个与变更响应相同的对象签名(Shape).通过此选贤,Relay知道如何立即更新本地数据,并在成功响应时更新,出错时回滚.

请注意实际情况中,代码里的查询和响应并不一定完全具有相同的签名(Shape),因为有时候Relay将在编译时添加一些额外的字段,并且您需要把这些字段添加到乐观响应.例如:
- 为了方便缓存,Relay添加id字段(如果存在的话).
- 如果类型是联合或者接口,Relay将添加一个__typename字段.
你可以在网络请求和响应中查看这些额外字段.

### 从变更响应中更新本地数据
一般情况下,Relay知道通过变更中应用的记录来如何更新字段, (例如例子中的todo). 然而,这些都是最简单的例子.在某些场景下,更新本地数据并不是简单的更新记录的字段.

例如,我们可能需要更新集合,或者可能需要完全删掉某条记录.对于这些更高级的场景,Relay允许我们传入一组选项来控制我们如何从服务器响应来更新本地数据,包括一组配置和updater函数来控制更新.

关于变更和更新的更多的细节和高级用法,请查看文档[Mutations](mutations.md).

## 下一步
这篇指南仅仅是在Relay API上拼凑而成的.更多的细节文档和指南,请参考API参考和指南部分.