# 快速入门
我们将通过一个todo list程序作为例子, 简要介绍Relay是如何工作的,以及如何使用.更多信息,请参照详细文档和API部分.

内容列表
- [设置](#user-content-设置)
- [Relay环境](#user-content-Relay环境)
- [绘制GraphQL查询](#user-content-绘制GraphQL查询)
- [使用查询参数](#user-content-使用查询参数)
- [使用Fragments](#user-content-使用Fragments)
- [组合Fragments](#user-content-组合Fragments)
- [绘制Fragments](#user-content-绘制Fragments)
- [数据变更](#user-content-数据变更)
- [下一步](#user-content-下一步)

## 设置
您已经熟悉了[前置条件]()和[安装和启动](), 作为先决条件, 假定您已经设置了GraphQL服务和Schema.

幸运的是, 我们作为例子的todo list, 已经内置了服务和chema供使用.

```javascript
type Query {
    viewer: User

    # Fetches an object given its ID
    node(
        # The ID of an object
        id: ID!
    ): Node
}
```
另外,我们在代码内部使用[Flow](https://flow.org/).Flow是一个可选项,但是我们在示例中完全使用Flow.

## Relay环境
在我们使用Relay绘制程序之前,我们需要配置Relay环境:包括配置,缓存,网络处理.

作为例子,我们简单的配置环境和已存在的Graphql服务进行通讯.
```javascript
import {
    Environment,
    Network,
    RecordStore,
    Store
} from 'relay-runtime';

function fetchQuery(
    operation,
    variables,
) {
    return fetch('/graphql',{
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            query: operation.text,
            variables,
        }),
    }).then( response => response.json() );
}

const environment = new Enviroment({
    network: Network.create(fetchQuery),
    store: new Store( new RecordSource() ),
});

export default enviroment;
```

## 绘制GraphQL查询

## 使用查询参数

## 使用Fragments

## 组合Fragments

## 绘制Fragments

## 数据变更

## 下一步