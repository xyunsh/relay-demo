# 快速入门
我们将通过一个todo list程序作为例子, 简要介绍Relay是如何工作的,以及如何使用.更多信息,请参照详细文档和API部分.

内容列表
- [设置](#user-content-设置)
- [Relay环境](#user-content-Relay环境)
- [绘制GraphQL查询](#user-content-绘制GraphQL查询)
- [使用查询参数](#user-content-使用查询参数)
- [使用Fragments](#user-content-使用Fragments)
- [组合Fragments](#user-content-组合Fragments)
- [绘制Fragments](#user-content-绘制Fragments)
- [数据变更](#user-content-数据变更)
- [下一步](#user-content-下一步)

## 设置
您已经熟悉了[前置条件]()和[安装和启动](), 作为先决条件,假定您已经设置了GraphQL服务和Schema.

幸运的是, 我们作为例子的todo list, 已经内置了服务和chema供使用.

```javascript
type Query {
    viewer: User

    # Fetches an object given its ID
    node(
        # The ID of an object
        id: ID!
    ): Node
}
```
另外,我们在代码内部使用[Flow](https://flow.org/).Flow是一个可选项,但是我们在示例中完全使用Flow.

## Relay环境
在我们使用Relay绘制程序之前,我们需要配置Relay环境:包括配置,缓存,网络处理.

作为例子,我们简单的配置环境和已存在的Graphql服务进行通讯.
```javascript
import {
    Environment,
    Network,
    RecordStore,
    Store
} from 'relay-runtime';

function fetchQuery(
    operation,
    variables,
) {
    return fetch('/graphql',{
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            query: operation.text,
            variables,
        }),
    }).then( response => response.json() );
}

const environment = new Enviroment({
    network: Network.create(fetchQuery),
    store: new Store( new RecordSource() ),
});

export default enviroment;
```
Relay运行环境至少需要存储(Store)和网络层(Network layer).上面的代码使用了Store的缺省实现,并且创建了一个网络层(Network layer)用于fetchQuery函数获取来自服务端的GraphQL.

通常,我们在我们的应用中,我们需要一个简单的环境配置,所以你可以把这个配置作为单例导出,这样可以让整个程序访问.

## 绘制GraphQL查询
现在我们已经配置了Relay环境,我们可以开始获取查询数据并绘制在屏幕上.react-relay提供的[QueryRenderer](query-renderer.md)组件可以作为绘制GraphQL查询的进入点.

作为开始,我们假定需要在屏幕上绘制用户id.从我们的Schema可以得知可以通过viewer获取当前用户,因此我们可以书写一个简单的查询来获取当前用户id:
```javascript
query UserQuery {
    viewer {
        id
    }
}
```
现在,我们看看如何创建一个组件用户绘制上面的查询:
```javascript
// App.js
import React from 'react';
import {graphql, QueryRender} from 'react-relay';

const environment = /* defined or import above... */;

export default class App extends React.Component {
    render() {
        return (
            <QueryRender
                environment={environment}
                query={graphql`
                    query UserQuery {
                        viewer {
                            id
                        }
                    }
                `}
                variables={{}}
                render={({error, props})=>{
                    if(error){
                        return <div>Error!</div>;
                    }

                    if(!props){
                        return <div>Loading...</div>;
                    }

                    return <div>User ID: {props.viewer.id}</div>;
                }}
            />
        );
    }
}
```
上面的代码绘制了一个 QueryRenderer, 像其他的React组件一样, 我们看看在属性(props)传入了什么:
- 前面定义的 environment
- 使用graphl函数定义GraphQL查询. graphql不会在运行时执行,而是通过[Relay编译器](graphql-in-relay.md#relay-compiler)生成Relay需要的运行时工件. 这部分我们先不关心,更多的细节请参考[GraphQL in Relay](graphql-in-relay.md)文档.
- 空对象 variables. 下一节我们再讨论如何使用variables.
- render函数,从代码中我们可以看到,Relay会给出一些错误信息,以及是否还在执行query.如果调用成功,数据将在props中可用,名称和查询中一致.

我们需要先使用Relay Compiler编译查询才能运行程序. 如果在[安装和设置](3.installatin-and-setup.md)设置好了,我可以直接运行 yarn relay.

关于 QueryRenderer 更多的细节,我们可以查看[文档](query-renderer.md).

## 使用查询参数
假设我们的程序需要展示不同的用户信息,因此我们需要通过id查询用户.从[schema](https://github.com/relayjs/relay-examples/blob/master/todo/data/schema.graphql#L69)中我们可以了解可以通过id查询信息. 因此我们可以书写如下的参数化查询:
```
query UserQuery($userID: ID!) {
    node(id: $userID){
        id
    }
}
```
下面我们看看如何使用上面的查询:
```javascript
// UserTodoList.js
// @flow
import React from 'react';
import PropTypes from 'prop-types';
import {graphql, QueryRenderer} from 'react-relay';

const environment = /* defined or imported above... */;

type Props = {
    userID: string,
}

export default class UserTodoList extends React.COmponent<Props> {
    render() {
        const { userID } = this.props;

        return (
            <QueryRenderer
                environment={environment}
                query={
                    graphql`
                        query UserQuery($userID: ID!){
                            node(id: $userID) {
                                id
                            }
                        }
                    `
                }
                variables={{userID}}
                render={({error,props})=>{
                    if(error){
                        return <div>Error!</div>;
                    }

                    if(!props){
                        return <div>Loading...</div>;
                    }

                    return <div>User ID:{props.node.id}</div>;
                }}
            />
        );
    }
}
```
上面的代码和[之前例子](quick-start-guide.md#rendering-graphql-queries)非常相似. 不管怎样,我们通过variables属性传入$userID变量给GraphQL查询.这里有些需要注意的地方:
- userID 作为组件的属性,可能从父组件传入新的userID。这时候新的variables将传入QueryRenderer,这将自动导致根据新的userID重新从服务端获取数据.
- $userID变量可以在查询内部任何地方都可以访问,当组件作为fragments使用的时候,这一点非常重要.

现在我们需要更新查询, 不要忘记运行yarn relay.

## 使用Fragments
现在我们开始学习如何定义和使用查询,我们开始真正创建todo list.

我们从下面的代码开始,假设我们仅仅需要一个显示todo item的文本和完成状态的组件:
```javascript
// Todo.js
import React from 'react';

type Props = {
    todo: {
        complete:boolean,
        text:string
    },
};

export default class Todo extends React.Component<Props>{
    render(){
        const { complete, text } = this.props.todo;

        return (
            <li>
                <div>
                    <input checked={complete} type="checkbox"/>
                    <label>{text}</label>
                </div>
            </li>
        );
    }
}

```

从schema中,我们可以知道可以通过Todo类型来查询这些数据. 然而,我们并不想对每一个todo item发送一个查询请求;这会破坏在传统Rest API上使用GraphQL的目的.我们可以在QueryRenderer上直接手动处理这些字段，但是这样又会破坏重用性:我们如何通过一个查询的一部分来查询这些字段？我们并不知道哪些组件需要我们查询的这些数据,这将是Relay需要直面解决的问题.

相反,我们可以定义一个可复用的Fragment,允许我们在一个类型上定义一个字段的集合，并可以在我们的任何需要的地方重用它们:
```javascript
fragment TodoItemFragment on Todo {
    complete,
    text
}
```
我们的组件可以使用fragment去申明它在Todo GraphQL类型上的数据依赖.
```javascript
// Todo.js

// OPTIONAL: Flow type generated after running `yarn relay`, defining an Object type with shape of fragment
import type { Todo_todo } from './__generated__/Todo_todo.graphql';

import React from 'react';
import { graphql, createFragmentContainer } from 'react-relay';

type Props = {
    todo: Todo_todo
};

class Todo extends React.Component<Props>{
    render(){
        const { complete, text } = this.props.todo;

        return (
            <li>
                <div>
                    <input checked={ complete } type="checkbox"/>
                    <label>{text}</label>
                </div>
            </li>
        );
    }
}

export default createFragmentContainer(
    Todo,
    graphql`
        fragment Todo_todo on Todo {
            complete,
            text
        }
    `
)
```


## 组合Fragments

## 绘制Fragments

## 数据变更

## 下一步